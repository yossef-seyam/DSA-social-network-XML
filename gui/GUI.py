import tkinter as tk
from tkinter import filedialog, messagebox, scrolledtext, simpledialog
import subprocess
import os
import csv

# --- LIBRARIES FOR GRAPHING ---
try:
    import networkx as nx
    import matplotlib.pyplot as plt
    HAS_GRAPH_LIBS = True
except ImportError:
    HAS_GRAPH_LIBS = False
    print("Warning: networkx or matplotlib not found. Graphing will be disabled.")

# ================== GRAPHING LOGIC ==================
def draw_social_network(csv_file='graph.csv'):
    # 1. Create a Directed Graph (DiGraph is required for arrows)
    G = nx.DiGraph()
    full_path = os.path.abspath(csv_file)
    
    # 2. Read the CSV file generated by C++
    if not os.path.exists(full_path):
        print(f"Error: {full_path} not found. Run 'xml_editor draw' first.")
        messagebox.showerror("Error", f"Graph file not found at:\n{full_path}")
        return
    print(f"Reading {full_path}...")
    try:
        with open(full_path, 'r', encoding='utf-8', errors='ignore') as f:
            reader = csv.reader(f)
            for row in reader:
                if len(row) >= 2:
                    source, target = row[0].strip(), row[1].strip()
                    if source and target:
                        G.add_edge(source, target)
    except Exception as e:
        messagebox.showerror("Read Error", f"Could not read CSV: {e}")
        return

    if G.number_of_nodes() == 0:
        print("Graph is empty.")
        messagebox.showwarning("Warning", "The generated graph CSV is empty.\nCheck if the input XML has valid following/follower data.")
        return
    
   
    # 3. Setup the Drawing Style
    try:
        plt.figure(figsize=(12, 10)) # Large window
        
        # "Spring Layout" spreads nodes apart so arrows are visible
        # k=0.8 increases the distance between nodes (prevents crowding)
        pos = nx.spring_layout(G, k=0.8, iterations=50) 
        
        # A. Draw Nodes (Blue Circles)
        nx.draw_networkx_nodes(G, pos, 
                            node_size=2500, 
                            node_color='#6495ED', # Cornflower Blue
                            edgecolors='black')   # Black border around circle

        # B. Draw Labels (The ID Numbers inside the dots)
        nx.draw_networkx_labels(G, pos, 
                                font_size=14, 
                                font_family='sans-serif',
                                font_weight='bold',
                                font_color='white')

        # C. Draw Edges with ARROW HEADS
        nx.draw_networkx_edges(G, pos, 
                            width=2, 
                            arrows=True,          # Force arrows on
                            arrowstyle='-|>',     # Triangle shape pointing to target
                            arrowsize=30,         # Large size for visibility
                            edge_color='gray',
                            min_source_margin=25, # Start line away from center of source node
                            min_target_margin=25, # End line at border of target node
                            connectionstyle="arc3,rad=0.1") # Curve lines slightly

        # 4. Finalize and Show
        plt.title("Social Network Graph", fontsize=16)
        plt.axis('off') 
        
        # Save to file
        output_img = os.path.join(os.path.dirname(full_path), "social_network_plot.png")
        print(f"Graph saved to {output_img}")
        
        plt.title("Social Network Analysis", fontsize=15)
        plt.axis('off')
        plt.show()
    except Exception as e:
        messagebox.showerror("Plot Error", str(e))

# ================== MAIN APP LOGIC ==================
def run_cpp_command(action, extra_args=None):
    # 1. Prepare Input
    manual_text = text_input.get("1.0", tk.END).strip()
    input_filename = "temp_input.xml"
    
    # If user typed manual text, save it to a temporary file
    if manual_text:
        input_filename = os.path.abspath("temp_input.xml")
        with open(input_filename, "w") as f: f.write(manual_text)
    elif entry_file_path.get():
        # FIX: Convert user input to Absolute Path immediately
        input_filename = os.path.abspath(entry_file_path.get())
    else:
        messagebox.showerror("Error", "Please select a file OR paste XML text.")
        return

    # 2. Prepare Output Filename
    
    output_filename = entry_output_path.get()
    if output_filename:
        output_filename = os.path.abspath(output_filename) 
    else:
        base_dir = os.path.dirname(input_filename)
        if action == "compress": output_filename = "out.comp"
        elif action == "json": output_filename = "out.json"
        elif action == "draw": output_filename = "graph.csv"
        else: output_filename = "out.xml"
        output_filename = os.path.join(base_dir, output_filename)

    current_dir = os.path.dirname(os.path.abspath(__file__))
    exe_path = os.path.join(current_dir, "..", "bin", "xml_editor.exe")
    exe_path = os.path.abspath(exe_path)

    if not os.path.exists(exe_path):
        messagebox.showerror("Configuration Error", f"Could not find executable at:\n{exe_path}\n\nPlease compile the project first!")
        return
    
    # 3. Construct Command
    cmd = [exe_path, action, "-i", input_filename, "-o", output_filename]
    if action == "verify": cmd.append("-f")
    if extra_args: cmd.extend(extra_args)
    
    output_dir = os.path.dirname(output_filename)
    
    print(f"Running command: {' '.join(cmd)}") # Debug print

    # 4. Execute
    try:
        result = subprocess.run(cmd, capture_output=True, text=True, encoding='utf-8', errors='replace')
        
        # Logs
        text_output.config(state=tk.NORMAL)
        text_output.delete("1.0", tk.END)
        if result.stdout.strip():
            text_output.insert(tk.END, "--- OUTPUT ---\n" + result.stdout + "\n")
        if result.stderr.strip():
             text_output.insert(tk.END, "\n--- ERROR LOG ---\n" + result.stderr + "\n")

        # Show Content
        if os.path.exists(output_filename) and action not in ["draw", "compress"]:
            text_output.insert(tk.END, f"\n--- FILE: {output_filename} ---\n")
            try:
                with open(output_filename, "r") as f: text_output.insert(tk.END, f.read())
            except: text_output.insert(tk.END, "[Binary/Large File]")
        
        text_output.config(state=tk.DISABLED)

        # Draw Graph if requested
        if action == "draw":
            if os.path.exists(output_filename):
                draw_social_network(output_filename)
            else:
                messagebox.showerror("Error", "Graph CSV was not created.")

    except Exception as e:
        messagebox.showerror("Execution Error", str(e))

# Helpers for Inputs
def run_id_cmd(cmd):
    val = simpledialog.askstring("Input", "Enter ID:")
    if val: run_cpp_command(cmd, ["-id", val])

def run_ids_cmd():
    val = simpledialog.askstring("Input", "Enter IDs (e.g. 1,2,3):")
    if val: run_cpp_command("mutual", ["-ids", val])

def run_search():
    # 1. Create a Custom Popup for Selection
    search_window = tk.Toplevel(root)
    search_window.title("Search Type")
    search_window.geometry("300x120")
    
    # Variable to store choice
    choice_var = tk.StringVar(value="")

    def set_topic():
        choice_var.set("topic")
        search_window.destroy()

    def set_word():
        choice_var.set("word")
        search_window.destroy()

    tk.Label(search_window, text="Select Search Type:", font=("Arial", 12)).pack(pady=10)
    
    btn_frame = tk.Frame(search_window)
    btn_frame.pack()
    
    tk.Button(btn_frame, text="TOPIC", command=set_topic, width=10, bg="#add8e6").pack(side=tk.LEFT, padx=10)
    tk.Button(btn_frame, text="WORD", command=set_word, width=10, bg="#90ee90").pack(side=tk.LEFT, padx=10)
    
    # Wait for the user to click a button
    root.wait_window(search_window)
    
    # 2. Process Choice
    user_choice = choice_var.get()
    if not user_choice:
        return # User closed window without choosing

    # 3. Ask for the String
    prompt_text = f"Enter the {user_choice.upper()} to search for:"
    val = simpledialog.askstring("Search Input", prompt_text)
    
    if val:
        flag = "-t" if user_choice == "topic" else "-w"
        run_cpp_command("search", [flag, val])

# ================== GUI LAYOUT ==================
root = tk.Tk()
root.title("DSA Project - XML Editor")
root.geometry("950x750")

# Input Section
frame_in = tk.Frame(root); frame_in.pack(pady=10)
tk.Label(frame_in, text="Input File:").pack(side=tk.LEFT)
entry_file_path = tk.Entry(frame_in, width=50); entry_file_path.pack(side=tk.LEFT, padx=5)
def browse():
    f = filedialog.askopenfilename(filetypes=[("All", "*.*"), ("XML", "*.xml")])
    entry_file_path.delete(0, tk.END); entry_file_path.insert(0, f)
tk.Button(frame_in, text="Browse", command=browse).pack(side=tk.LEFT)

tk.Label(root, text="OR Manual Input:").pack()
text_input = scrolledtext.ScrolledText(root, height=5, width=100); text_input.pack(pady=5)

# Output Section
frame_out = tk.Frame(root); frame_out.pack(pady=5)
tk.Label(frame_out, text="Output File:").pack(side=tk.LEFT)
entry_output_path = tk.Entry(frame_out, width=50); entry_output_path.pack(side=tk.LEFT, padx=5)

# --- NEW CODE: Add the Browse Button ---
def browse_out():
    f = filedialog.asksaveasfilename(defaultextension=".xml", filetypes=[("XML", "*.xml"), ("JSON", "*.json"), ("All", "*.*")])
    if f:
        entry_output_path.delete(0, tk.END)
        entry_output_path.insert(0, f)
tk.Button(frame_out, text="Browse", command=browse_out).pack(side=tk.LEFT)
# ---------------------------------------

# Buttons - Part 1
frame_p1 = tk.LabelFrame(root, text="Part 1: Parsing & Format", padx=5, pady=5); frame_p1.pack(pady=5)
tk.Button(frame_p1, text="Verify", width=10, bg="#ffcccb", command=lambda: run_cpp_command("verify")).pack(side=tk.LEFT, padx=5)
tk.Button(frame_p1, text="Format", width=10, bg="#90ee90", command=lambda: run_cpp_command("format")).pack(side=tk.LEFT, padx=5)
tk.Button(frame_p1, text="Minify", width=10, bg="#add8e6", command=lambda: run_cpp_command("mini")).pack(side=tk.LEFT, padx=5)
tk.Button(frame_p1, text="To JSON", width=10, bg="#ffffe0", command=lambda: run_cpp_command("json")).pack(side=tk.LEFT, padx=5)
tk.Button(frame_p1, text="Compress", width=10, bg="#d3d3d3", command=lambda: run_cpp_command("compress")).pack(side=tk.LEFT, padx=5)
tk.Button(frame_p1, text="Decompress", width=10, bg="#d3d3d3", command=lambda: run_cpp_command("decompress")).pack(side=tk.LEFT, padx=5)

# Buttons - Part 2
frame_p2 = tk.LabelFrame(root, text="Part 2: Network Analysis", padx=5, pady=5); frame_p2.pack(pady=5)
tk.Button(frame_p2, text="Most Active", width=12, command=lambda: run_cpp_command("most_active")).pack(side=tk.LEFT, padx=2)
tk.Button(frame_p2, text="Most Influencer", width=12, command=lambda: run_cpp_command("most_influencer")).pack(side=tk.LEFT, padx=2)
tk.Button(frame_p2, text="Mutual Users", width=12, command=run_ids_cmd).pack(side=tk.LEFT, padx=2)
tk.Button(frame_p2, text="Suggest", width=12, command=lambda: run_id_cmd("suggest")).pack(side=tk.LEFT, padx=2)
tk.Button(frame_p2, text="Search", width=12, command=run_search).pack(side=tk.LEFT, padx=2)
tk.Button(frame_p2, text="Draw Graph", width=12, bg="violet", command=lambda: run_cpp_command("draw")).pack(side=tk.LEFT, padx=2)

# Output Log
tk.Label(root, text="System Output:").pack()
text_output = scrolledtext.ScrolledText(root, height=15, width=110, state=tk.DISABLED); text_output.pack(pady=10)

root.mainloop()