import tkinter as tk
from tkinter import filedialog, messagebox, scrolledtext, simpledialog
import subprocess
import os
import csv

# --- LIBRARIES FOR GRAPHING ---
try:
    import networkx as nx
    import matplotlib.pyplot as plt
    HAS_GRAPH_LIBS = True
except ImportError:
    HAS_GRAPH_LIBS = False
    print("Warning: networkx or matplotlib not found. Graphing will be disabled.")

# ================== GRAPHING LOGIC ==================
def draw_social_network(csv_file='graph.csv'):
    # 1. Create a Directed Graph (DiGraph is required for arrows)
    G = nx.DiGraph()
    
    # 2. Read the CSV file generated by C++
    if not os.path.exists(csv_file):
        print(f"Error: {csv_file} not found. Run 'xml_editor draw' first.")
        return

    print(f"Reading {csv_file}...")
    try:
        with open(csv_file, 'r') as f:
            reader = csv.reader(f)
            for row in reader:
                if len(row) >= 2:
                    # Logic: row[0] follows row[1]
                    # Arrow will point FROM Source TO Target
                    source, target = row[0], row[1]
                    G.add_edge(source, target)
    except Exception as e:
        print(f"Error reading CSV: {e}")
        return

    if G.number_of_nodes() == 0:
        print("Graph is empty.")
        return

    # 3. Setup the Drawing Style
    plt.figure(figsize=(12, 10)) # Large window
    
    # "Spring Layout" spreads nodes apart so arrows are visible
    # k=0.8 increases the distance between nodes (prevents crowding)
    pos = nx.spring_layout(G, k=0.8, iterations=50) 
    
    # A. Draw Nodes (Blue Circles)
    nx.draw_networkx_nodes(G, pos, 
                           node_size=2500, 
                           node_color='#6495ED', # Cornflower Blue
                           edgecolors='black')   # Black border around circle

    # B. Draw Labels (The ID Numbers inside the dots)
    nx.draw_networkx_labels(G, pos, 
                            font_size=14, 
                            font_family='sans-serif',
                            font_weight='bold',
                            font_color='white')

    # C. Draw Edges with ARROW HEADS
    nx.draw_networkx_edges(G, pos, 
                           width=2, 
                           arrows=True,          # Force arrows on
                           arrowstyle='-|>',     # Triangle shape pointing to target
                           arrowsize=30,         # Large size for visibility
                           edge_color='gray',
                           min_source_margin=25, # Start line away from center of source node
                           min_target_margin=25, # End line at border of target node
                           connectionstyle="arc3,rad=0.1") # Curve lines slightly

    # 4. Finalize and Show
    plt.title("Social Network Graph", fontsize=16)
    plt.axis('off') 
    
    current_dir = os.path.dirname(os.path.abspath(__file__))
    data_dir = os.path.join(current_dir, "..", "data")
    data_dir = os.path.abspath(data_dir)
    
    # Save to file
    output_img = os.path.join(data_dir, f"Social Network Analysis python.png")
    # output_img = "social_network_plot.png"
    plt.savefig(output_img, format="PNG", dpi=300) 
    print(f"Python Graph saved to {output_img}")
    
    plt.title("Social Network Analysis", fontsize=15)
    plt.axis('off')
    plt.show()

# ================== MAIN APP LOGIC ==================
def run_cpp_command(action, extra_args=None):
    # 1. Prepare Input
    manual_text = text_input.get("1.0", tk.END).strip()
    input_filename = "temp_input.xml"
    
    if manual_text:
        # Save to data folder, not current directory
        current_dir = os.path.dirname(os.path.abspath(__file__))
        data_dir = os.path.join(current_dir, "..", "data")
        data_dir = os.path.abspath(data_dir)
        
        input_filename = os.path.join(data_dir, "temp_input.xml")
        with open(input_filename, "w") as f: 
            f.write(manual_text)
    elif entry_file_path.get():
        input_filename = entry_file_path.get()
    else:
        messagebox.showerror("Error", "Please select a file OR paste XML text.")
        return

    # 2. Prepare Output Filename - Save to data folder
    output_filename = entry_output_path.get()
    
    # Get the data folder path
    current_dir = os.path.dirname(os.path.abspath(__file__))
    data_dir = os.path.join(current_dir, "..", "data")
    data_dir = os.path.abspath(data_dir)
    
    if not output_filename:
        # Generate default filename based on action
        if action == "compress": 
            output_filename = os.path.join(data_dir, "out.comp")
        elif action == "json": 
            output_filename = os.path.join(data_dir, "out.json")
        elif action == "draw": 
            output_filename = os.path.join(data_dir, "social_graph_using_cpp.png")  # PNG file
        else: 
            output_filename = os.path.join(data_dir, "out.xml")
    else:
        # If user provided output, check if it's relative or absolute
        if not os.path.isabs(output_filename):
            # Make it relative to data folder
            output_filename = os.path.join(data_dir, output_filename)
        output_filename = os.path.abspath(output_filename)

    # 3. Get executable path
    exe_path = os.path.join(current_dir, "..", "bin", "xml_editor.exe")
    exe_path = os.path.abspath(exe_path)

    if not os.path.exists(exe_path):
        messagebox.showerror("Configuration Error", 
                           f"Could not find executable at:\n{exe_path}\n\nPlease compile the project first!")
        return
    
    # 4. Construct Command
    cmd = [exe_path, action, "-i", input_filename, "-o", output_filename]
    if action == "verify": 
        cmd.append("-f")
    if extra_args: 
        cmd.extend(extra_args)

    # 5. Execute
    try:
        # For draw action, we need special handling
        if action == "draw":
            
            input_dir = os.path.dirname(os.path.abspath(input_filename))
            # Run from data directory so CSV is created there
            result = subprocess.run(cmd, capture_output=True, text=True, cwd=input_dir)
    
            # The CSV will be in input_dir, PNG at output_filename
            csv_file = os.path.join(input_dir, "graph.csv")
            png_file = output_filename
            
            # Display results
            text_output.config(state=tk.NORMAL)
            text_output.delete("1.0", tk.END)
            if result.stdout.strip():
                text_output.insert(tk.END, "--- CONSOLE OUTPUT ---\n" + result.stdout + "\n")
            
            # Check if files were created
            if os.path.exists(csv_file):
                text_output.insert(tk.END, f"✓ CSV created at: {csv_file}\n")
            if os.path.exists(png_file):
                text_output.insert(tk.END, f"✓ PNG created at: {png_file}\n")
            
            text_output.config(state=tk.DISABLED)
            
            # Use the CSV from data folder for drawing
            if os.path.exists(csv_file):
                draw_social_network(csv_file)
            else:
                messagebox.showerror("Error", f"CSV file not created in:\n{data_dir}")
        else:
            # For other actions, run normally
            result = subprocess.run(cmd, capture_output=True, text=True)
            
            # Display Logs
            text_output.config(state=tk.NORMAL)
            text_output.delete("1.0", tk.END)
            if result.stdout.strip():
                text_output.insert(tk.END, "--- CONSOLE OUTPUT ---\n" + result.stdout + "\n")
            
            # Display File Content (if text based)
            if os.path.exists(output_filename) :
                text_output.insert(tk.END, f"\n--- FILE: {output_filename} ---\n")
                try:
                    with open(output_filename, "r") as f: 
                        text_output.insert(tk.END, f.read())
                except: 
                    text_output.insert(tk.END, "[Binary or Large File - Content Hidden]")
            
            text_output.config(state=tk.DISABLED)

    except Exception as e:
        messagebox.showerror("Execution Error", str(e))

# Helpers for Inputs
def run_id_cmd(cmd):
    val = simpledialog.askstring("Input", "Enter ID:")
    if val: run_cpp_command(cmd, ["-id", val])

def run_ids_cmd():
    val = simpledialog.askstring("Input", "Enter IDs (e.g. 1,2,3):")
    if val: run_cpp_command("mutual", ["-ids", val])

def run_search():
    # 1. Create a Custom Popup for Selection
    search_window = tk.Toplevel(root)
    search_window.title("Search Type")
    search_window.geometry("300x120")
    
    # Variable to store choice
    choice_var = tk.StringVar(value="")

    def set_topic():
        choice_var.set("topic")
        search_window.destroy()

    def set_word():
        choice_var.set("word")
        search_window.destroy()

    tk.Label(search_window, text="Select Search Type:", font=("Arial", 12)).pack(pady=10)
    
    btn_frame = tk.Frame(search_window)
    btn_frame.pack()
    
    tk.Button(btn_frame, text="TOPIC", command=set_topic, width=10, bg="#add8e6").pack(side=tk.LEFT, padx=10)
    tk.Button(btn_frame, text="WORD", command=set_word, width=10, bg="#90ee90").pack(side=tk.LEFT, padx=10)
    
    # Wait for the user to click a button
    root.wait_window(search_window)
    
    # 2. Process Choice
    user_choice = choice_var.get()
    if not user_choice:
        return # User closed window without choosing

    # 3. Ask for the String
    prompt_text = f"Enter the {user_choice.upper()} to search for:"
    val = simpledialog.askstring("Search Input", prompt_text)
    
    if val:
        flag = "-t" if user_choice == "topic" else "-w"
        run_cpp_command("search", [flag, val])
# ================== GUI LAYOUT ==================
root = tk.Tk()
root.title("DSA Project - XML Editor")
root.geometry("950x750")

# Input Section
frame_in = tk.Frame(root); frame_in.pack(pady=10)
tk.Label(frame_in, text="Input File:").pack(side=tk.LEFT)
entry_file_path = tk.Entry(frame_in, width=50); entry_file_path.pack(side=tk.LEFT, padx=5)
def browse():
    # Start in data folder
    current_dir = os.path.dirname(os.path.abspath(__file__))
    data_dir = os.path.join(current_dir, "..", "data")
    data_dir = os.path.abspath(data_dir)
    
    f = filedialog.askopenfilename(
        initialdir=data_dir,
        filetypes=[("All", "*.*"), ("XML", "*.xml")]
    )
    if f:
        entry_file_path.delete(0, tk.END)
        entry_file_path.insert(0, f)
tk.Button(frame_in, text="Browse", command=browse).pack(side=tk.LEFT)

tk.Label(root, text="OR Manual Input:").pack()
text_input = scrolledtext.ScrolledText(root, height=5, width=100); text_input.pack(pady=5)

# Output Section
frame_out = tk.Frame(root); frame_out.pack(pady=5)
tk.Label(frame_out, text="Output File:").pack(side=tk.LEFT)
entry_output_path = tk.Entry(frame_out, width=50); entry_output_path.pack(side=tk.LEFT, padx=5)

# --- NEW CODE: Add the Browse Button ---
def browse_out():
    # Start in data folder
    current_dir = os.path.dirname(os.path.abspath(__file__))
    data_dir = os.path.join(current_dir, "..", "data")
    data_dir = os.path.abspath(data_dir)
    
    f = filedialog.asksaveasfilename(
        initialdir=data_dir,
        defaultextension=".xml",
        filetypes=[("XML", "*.xml"), ("JSON", "*.json"), ("All", "*.*")]
    )
    if f:
        entry_output_path.delete(0, tk.END)
        entry_output_path.insert(0, f)
tk.Button(frame_out, text="Browse", command=browse_out).pack(side=tk.LEFT)
# ---------------------------------------

# Buttons - Part 1
frame_p1 = tk.LabelFrame(root, text="Part 1: Parsing & Format", padx=5, pady=5); frame_p1.pack(pady=5)
tk.Button(frame_p1, text="Verify", width=10, bg="#ffcccb", command=lambda: run_cpp_command("verify")).pack(side=tk.LEFT, padx=5)
tk.Button(frame_p1, text="Format", width=10, bg="#90ee90", command=lambda: run_cpp_command("format")).pack(side=tk.LEFT, padx=5)
tk.Button(frame_p1, text="Minify", width=10, bg="#add8e6", command=lambda: run_cpp_command("mini")).pack(side=tk.LEFT, padx=5)
tk.Button(frame_p1, text="To JSON", width=10, bg="#ffffe0", command=lambda: run_cpp_command("json")).pack(side=tk.LEFT, padx=5)
tk.Button(frame_p1, text="Compress", width=10, bg="#d3d3d3", command=lambda: run_cpp_command("compress")).pack(side=tk.LEFT, padx=5)
tk.Button(frame_p1, text="Decompress", width=10, bg="#d3d3d3", command=lambda: run_cpp_command("decompress")).pack(side=tk.LEFT, padx=5)

# Buttons - Part 2
frame_p2 = tk.LabelFrame(root, text="Part 2: Network Analysis", padx=5, pady=5); frame_p2.pack(pady=5)
tk.Button(frame_p2, text="Most Active", width=12, command=lambda: run_cpp_command("most_active")).pack(side=tk.LEFT, padx=2)
tk.Button(frame_p2, text="Most Influencer", width=12, command=lambda: run_cpp_command("most_influencer")).pack(side=tk.LEFT, padx=2)
tk.Button(frame_p2, text="Mutual Users", width=12, command=run_ids_cmd).pack(side=tk.LEFT, padx=2)
tk.Button(frame_p2, text="Suggest", width=12, command=lambda: run_id_cmd("suggest")).pack(side=tk.LEFT, padx=2)
tk.Button(frame_p2, text="Search", width=12, command=run_search).pack(side=tk.LEFT, padx=2)
tk.Button(frame_p2, text="Draw Graph", width=12, bg="violet", command=lambda: run_cpp_command("draw")).pack(side=tk.LEFT, padx=2)

# Output Log
tk.Label(root, text="System Output:").pack()
text_output = scrolledtext.ScrolledText(root, height=15, width=110, state=tk.DISABLED); text_output.pack(pady=10)

root.mainloop()